"use strict";(self.webpackChunkeasybitedocs=self.webpackChunkeasybitedocs||[]).push([[8719],{7960:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"syntax/modules","title":"Modules","description":"A module in EasyBite is a logical collection of code that is packaged and stored in a separate file to make it reusable, organized, and easier to maintain. These modules contain functions, variables, constants, classes, and other reusable code blocks that you can import into other programs or files. The primary purpose of modules is to promote code reusability and modularity, which helps to keep the codebase clean, manageable, and maintainable.","source":"@site/docs/syntax/modules.md","sourceDirName":"syntax","slug":"/syntax/modules","permalink":"/syntax/modules","draft":false,"unlisted":false,"editUrl":"https://github.com/Easybitedocs/easybitedocs.github.io/tree/main/docs/syntax/modules.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling in EasyBite","permalink":"/syntax/error-handling"},"next":{"title":"Functions","permalink":"/functions/function-concept"}}');var t=s(4848),i=s(8453);const r={},a="Modules",l={},d=[{value:"Why Use Modules?",id:"why-use-modules",level:3},{value:"Structure of a Module in EasyBite",id:"structure-of-a-module-in-easybite",level:3},{value:"Types of Modules",id:"types-of-modules",level:3},{value:"How Does a Module Work?",id:"how-does-a-module-work",level:3},{value:"Importing Modules in EasyBite",id:"importing-modules-in-easybite",level:2},{value:"Example of Importing a Custom Module",id:"example-of-importing-a-custom-module",level:3},{value:"Example of Importing Built-in Modules",id:"example-of-importing-built-in-modules",level:3},{value:"Importing Multiple Functions or Classes",id:"importing-multiple-functions-or-classes",level:3},{value:"Example of Importing a Class from a Module",id:"example-of-importing-a-class-from-a-module",level:3},{value:"Example of Importing a Class and Function Together",id:"example-of-importing-a-class-and-function-together",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"modules",children:"Modules"})}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"module"})," in EasyBite is a logical collection of code that is packaged and stored in a separate file to make it reusable, organized, and easier to maintain. These modules contain functions, variables, constants, classes, and other reusable code blocks that you can import into other programs or files. The primary purpose of modules is to promote ",(0,t.jsx)(n.strong,{children:"code reusability"})," and ",(0,t.jsx)(n.strong,{children:"modularity"}),", which helps to keep the codebase clean, manageable, and maintainable."]}),"\n",(0,t.jsx)(n.p,{children:"In EasyBite, modules allow developers to divide their code into smaller, focused files, each responsible for a particular task or functionality. This division enables developers to organize their code logically, making it easier to test, update, and expand."}),"\n",(0,t.jsx)(n.h3,{id:"why-use-modules",children:"Why Use Modules?"}),"\n",(0,t.jsx)(n.p,{children:"Modules in programming, including EasyBite, offer a host of benefits:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": Once a module is created, it can be reused in multiple programs or files, reducing the need to rewrite the same code multiple times. If you need to change the logic, you only need to modify the module, and all programs that use it will automatically reflect those changes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Organization and Structure"}),": By breaking your code into multiple modules, you can organize it into logical components, making it easier to maintain, understand, and debug. For example, one module might handle string operations, another might handle file I/O, and another could provide mathematical functions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Separation of Concerns"}),": Modules allow you to separate different concerns of the program into distinct sections. For instance, if your program handles both networking and user interface tasks, you could have separate modules for each, making your code cleaner and easier to manage."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Maintainability"}),": With a well-structured modular codebase, updating or fixing bugs becomes easier. If an error is found in one module, you can address it without affecting the rest of the code. This reduces the risk of breaking other parts of the program."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": As your program grows, the modular approach allows you to scale the project effectively by adding more modules without overwhelming the entire system. This also makes collaborative work more efficient since different developers can work on different modules concurrently."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Namespace Management"}),": Modules help avoid name clashes. Since each module creates its own namespace, variables, and functions within the module do not conflict with those in other parts of the program."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"structure-of-a-module-in-easybite",children:"Structure of a Module in EasyBite"}),"\n",(0,t.jsx)(n.p,{children:"A module in EasyBite is simply a file that contains code (functions, variables, classes, etc.) that can be imported into another program or module. Modules do not need to follow any particular internal structure, but typically, a module will contain functions or classes that are logically grouped based on their functionality."}),"\n",(0,t.jsx)(n.p,{children:"For example, a module might contain functions related to math operations, file I/O functions, or user interface helpers. Here is a basic example of what a module might look like:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"math_operations.eb"})}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// math_operations.eb - A module for basic math functions\r\n\r\n// Function to add two numbers\r\nfunction add(a, b)\r\n    return a + b\r\nend function\r\n\r\n// Function to subtract two numbers\r\nfunction subtract(a, b)\r\n    return a - b\r\nend function\r\n\r\n// Function to multiply two numbers\r\nfunction multiply(a, b)\r\n    return a * b\r\nend function\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"math_operations.eb"})," module can now be imported into other programs to use these functions, making it easier to perform math operations without having to rewrite the logic each time."]}),"\n",(0,t.jsx)(n.h3,{id:"types-of-modules",children:"Types of Modules"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Built-in Modules"}),": These are modules that come pre-packaged with the EasyBite language. Built-in modules provide commonly used functionalities, such as math operations, file handling, and more. These modules are always available and do not need to be created or imported by the user."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Custom Modules"}),": These are modules that you, as a developer, create in your own projects. Custom modules allow you to organize your program into smaller, focused sections. You can create these modules and store them in a designated folder (typically called ",(0,t.jsx)(n.code,{children:"modules/"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-does-a-module-work",children:"How Does a Module Work?"}),"\n",(0,t.jsx)(n.p,{children:"When you import a module into your EasyBite program, the system searches for the module in a predefined set of locations and loads it into the program\u2019s namespace. This process makes the functions, variables, and classes inside the module available for use."}),"\n",(0,t.jsx)(n.p,{children:"The EasyBite runtime performs the following steps to handle module imports:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Check for Built-in Modules"}),": If the module is a built-in module, the system will immediately load it. Built-in modules are part of the EasyBite standard library, such as mathematical operations or data structures."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Check the Current Working Directory"}),": If the module is not built-in, the system will search the current directory where the program is being executed for a file with the same name as the module."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Check for a Directory with the Module Name"}),": If the module is not found in the current working directory, the system will check if there is a directory with the module's name. This is useful for organizing your code by separating modules into different directories."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Check for the ",(0,t.jsx)(n.code,{children:"BITE_MODULES"})," Environment Variable"]}),": If the module is still not found, and the environment variable ",(0,t.jsx)(n.code,{children:"BITE_MODULES"})," is set, the system will check the path specified in the environment variable to locate the module."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Check the ",(0,t.jsx)(n.code,{children:"/modules"})," Folder"]}),": Finally, if the module is not found in any of the above locations, the system will check the ",(0,t.jsx)(n.code,{children:"/modules"})," folder in the project directory."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Look for a Directory Named After the Module"}),": If all else fails, the system will look for a directory with the name of the module. This directory should contain a ",(0,t.jsx)(n.code,{children:"main.eb"})," file that acts as the entry point for the module."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This modular approach ensures that modules can be easily organized and reused across different projects and that the system is flexible in locating the necessary files."}),"\n",(0,t.jsx)(n.h2,{id:"importing-modules-in-easybite",children:"Importing Modules in EasyBite"}),"\n",(0,t.jsxs)(n.p,{children:["Once a module is located, it can be imported using the ",(0,t.jsx)(n.code,{children:"import"})," keyword. Here\u2019s the general syntax for importing a module in EasyBite:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Import a Custom Module"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"import modulename\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Import Built-in Modules"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"import math\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Import Specific Functions from a Module"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"from modulename import functionname\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-of-importing-a-custom-module",children:"Example of Importing a Custom Module"}),"\n",(0,t.jsxs)(n.p,{children:["Let\u2019s say you have a custom module named ",(0,t.jsx)(n.code,{children:"utils.eb"})," that contains helper functions for string manipulation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// utils.eb - A custom module with string manipulation functions\r\n\r\n// Function to concatenate two strings\r\nfunction concatenate(str1, str2)\r\n    return str1 + str2\r\nend function\n"})}),"\n",(0,t.jsx)(n.p,{children:"To import and use this module in your main program:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'import utils\r\n\r\nset greeting to utils.concatenate("Hello", "World")\r\nshow greeting  // Outputs: "HelloWorld"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-of-importing-built-in-modules",children:"Example of Importing Built-in Modules"}),"\n",(0,t.jsxs)(n.p,{children:["In EasyBite, built-in modules such as ",(0,t.jsx)(n.code,{children:"math"})," are available for mathematical operations. To use the math module:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"import math\r\n\r\nset sum to math.add(10, 5)\r\nshow sum  // Outputs: 15\n"})}),"\n",(0,t.jsx)(n.h3,{id:"importing-multiple-functions-or-classes",children:"Importing Multiple Functions or Classes"}),"\n",(0,t.jsx)(n.p,{children:"You can import multiple functions or classes from a module in one line:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"from math import add, subtract\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then, you can use them directly in your program:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"set result_add to add(10, 5)\r\nset result_subtract to subtract(10, 5)\r\n\r\nshow result_add  // Outputs: 15\r\nshow result_subtract  // Outputs: 5\n"})}),"\n",(0,t.jsx)(n.h3,{id:"example-of-importing-a-class-from-a-module",children:"Example of Importing a Class from a Module"}),"\n",(0,t.jsxs)(n.p,{children:["Suppose you have a module called ",(0,t.jsx)(n.code,{children:"shapes.eb"})," that contains a ",(0,t.jsx)(n.code,{children:"Circle"})," class to calculate the area of a circle:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"// shapes.eb - A module with a Circle class\r\n\r\nclass Circle\r\n    declare radius\r\n    \r\n    init(radius)\r\n        this.radius to radius\r\n    end init\r\n    \r\n    method calculate_area()\r\n        return 3.14 * self.radius * self.radius\r\n    end method\r\nend class\n"})}),"\n",(0,t.jsx)(n.p,{children:"To import and use this class:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'import shapes\r\n\r\nset my_circle to shapes.Circle(5)  // Create a Circle with radius 5\r\nset area to my_circle.calculate_area()\r\n\r\nshow "Area of the circle: " + area  // Outputs the area of the circle\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-of-importing-a-class-and-function-together",children:"Example of Importing a Class and Function Together"}),"\n",(0,t.jsx)(n.p,{children:"You can also import both a class and a function from the same module:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:"from shapes import Circle, square_area\r\n\r\nset square_result to square_area(4)\r\nset circle to Circle(5)\r\nset circle_area to circle.calculate_area()\r\n\r\nshow square_result  // Outputs: 16\r\nshow circle_area  // Outputs the area of the circle\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"Modules in EasyBite are powerful tools that allow you to organize, reuse, and maintain your code more efficiently. By breaking your program into smaller, manageable pieces, you can create more scalable and maintainable applications. The ability to import both built-in and custom modules enhances flexibility and reduces redundancy."}),"\n",(0,t.jsxs)(n.p,{children:["The search order for modules ensures that EasyBite can locate the necessary files, whether they are in the current directory, a specific directory, the ",(0,t.jsx)(n.code,{children:"/modules"})," folder, or even specified through environment variables. By using the ",(0,t.jsx)(n.code,{children:"import"})," statement effectively, you can build complex programs with minimal code repetition and maximum modularity."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);