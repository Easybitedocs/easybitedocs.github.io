"use strict";(self.webpackChunkeasybitedocs=self.webpackChunkeasybitedocs||[]).push([[1567],{5226:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Welcome","href":"/","docId":"index","unlisted":false},{"type":"category","label":"Getting Started","items":[{"type":"link","label":"Installation","href":"/getting-started/installation","docId":"getting-started/installation","unlisted":false},{"type":"link","label":"First Program","href":"/getting-started/first-program","docId":"getting-started/first-program","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Syntax","items":[{"type":"link","label":"Introduction","href":"/syntax/intro","docId":"syntax/intro","unlisted":false},{"type":"link","label":"Comments","href":"/syntax/comment","docId":"syntax/comment","unlisted":false},{"type":"link","label":"Keywords","href":"/syntax/keywords","docId":"syntax/keywords","unlisted":false},{"type":"link","label":"Variables","href":"/syntax/variables","docId":"syntax/variables","unlisted":false},{"type":"link","label":"Data Types and Operators","href":"/syntax/datatypes-operators","docId":"syntax/datatypes-operators","unlisted":false},{"type":"link","label":"Control Structures","href":"/syntax/control-structures","docId":"syntax/control-structures","unlisted":false},{"type":"link","label":"Loops","href":"/syntax/loops","docId":"syntax/loops","unlisted":false},{"type":"link","label":"Lists","href":"/syntax/list","docId":"syntax/list","unlisted":false},{"type":"link","label":"Dictionaries","href":"/syntax/dictionary","docId":"syntax/dictionary","unlisted":false},{"type":"link","label":"Error Handling in EasyBite","href":"/syntax/error-handling","docId":"syntax/error-handling","unlisted":false},{"type":"link","label":"Modules","href":"/syntax/modules","docId":"syntax/modules","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Functions","items":[{"type":"link","label":"Functions","href":"/functions/function-concept","docId":"functions/function-concept","unlisted":false},{"type":"link","label":"Default Arguments","href":"/functions/default-arguments","docId":"functions/default-arguments","unlisted":false},{"type":"link","label":"Calling Functions","href":"/functions/function-call","docId":"functions/function-call","unlisted":false},{"type":"link","label":"Variable Scope","href":"/functions/variable-scope","docId":"functions/variable-scope","unlisted":false},{"type":"link","label":"Callbacks in EasyBite","href":"/functions/callback-function","docId":"functions/callback-function","unlisted":false},{"type":"link","label":"Built\u2011in Functions","href":"/functions/builtin-functions","docId":"functions/builtin-functions","unlisted":false},{"type":"link","label":"Naming Convention","href":"/functions/naming-convension","docId":"functions/naming-convension","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Object Oriented Programming","items":[{"type":"link","label":"Object\u2011Oriented Programming (OOP)","href":"/oop/oop-concept","docId":"oop/oop-concept","unlisted":false},{"type":"link","label":"Classes and Objects","href":"/oop/classes-objects","docId":"oop/classes-objects","unlisted":false},{"type":"link","label":"Class Attributes","href":"/oop/class-attributes","docId":"oop/class-attributes","unlisted":false},{"type":"link","label":"Methods","href":"/oop/methods","docId":"oop/methods","unlisted":false},{"type":"link","label":"Constructors","href":"/oop/constructors","docId":"oop/constructors","unlisted":false},{"type":"link","label":"Access Modifiers","href":"/oop/access-modifiers","docId":"oop/access-modifiers","unlisted":false},{"type":"link","label":"Inheritance","href":"/oop/inheritance","docId":"oop/inheritance","unlisted":false},{"type":"link","label":"Encapsulation","href":"/oop/encapsulation","docId":"oop/encapsulation","unlisted":false},{"type":"link","label":"Polymorphism","href":"/oop/polymorphism","docId":"oop/polymorphism","unlisted":false},{"type":"link","label":"Class Relationships","href":"/oop/class-relationships","docId":"oop/class-relationships","unlisted":false},{"type":"link","label":"OOP Frequently Asked Questions (FAQ)","href":"/oop/oop-facts","docId":"oop/oop-facts","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Libraries","items":[{"type":"link","label":"Libraries in EasyBite","href":"/libraries/introduction","docId":"libraries/introduction","unlisted":false},{"type":"link","label":"Math Library Reference","href":"/libraries/math","docId":"libraries/math","unlisted":false},{"type":"link","label":"String Library Reference","href":"/libraries/string","docId":"libraries/string","unlisted":false},{"type":"link","label":"Array Library Reference","href":"/libraries/array","docId":"libraries/array","unlisted":false},{"type":"link","label":"Dict Library Reference","href":"/libraries/dictionary","docId":"libraries/dictionary","unlisted":false},{"type":"link","label":"DateTime Library Reference","href":"/libraries/datetime","docId":"libraries/datetime","unlisted":false},{"type":"link","label":"Convert Library Reference","href":"/libraries/conversion","docId":"libraries/conversion","unlisted":false},{"type":"link","label":"File System Library Reference","href":"/libraries/filesystem","docId":"libraries/filesystem","unlisted":false},{"type":"link","label":"SQLite Library Reference","href":"/libraries/sqlite","docId":"libraries/sqlite","unlisted":false},{"type":"link","label":"MySQL Library Reference","href":"/libraries/mysql","docId":"libraries/mysql","unlisted":false},{"type":"link","label":"Socket Library Reference","href":"/libraries/socket","docId":"libraries/socket","unlisted":false},{"type":"link","label":"Requester Library Reference","href":"/libraries/requester","docId":"libraries/requester","unlisted":false},{"type":"link","label":"Listener Library Reference","href":"/libraries/listener","docId":"libraries/listener","unlisted":false},{"type":"link","label":"System Library Reference","href":"/libraries/system","docId":"libraries/system","unlisted":false},{"type":"link","label":"Thread Library Reference","href":"/libraries/thread","docId":"libraries/thread","unlisted":false},{"type":"link","label":"Gui Library Reference","href":"/libraries/gui","docId":"libraries/gui","unlisted":false},{"type":"link","label":"Plotter Library Reference","href":"/libraries/plotter","docId":"libraries/plotter","unlisted":false},{"type":"link","label":"Gui Examples","href":"/libraries/guiexamples","docId":"libraries/guiexamples","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"functions/builtin-functions":{"id":"functions/builtin-functions","title":"Built\u2011in Functions","description":"EasyBite comes with a powerful suite of built\u2011in functions that you can use instantly\u2014no installation, no setup, no fuss. These functions live in the global scope and handle everyday tasks like printing output, reading user input, and manipulating binary data. In the sections that follow, we\u2019ll explore four of the most essential built\u2011ins in great detail, with clear, step\u2011by\u2011step explanations and plenty of examples that even a complete beginner can follow. Then we\u2019ll show you how to bring in additional functions from EasyBite\u2019s standard libraries, and finally point you to the full reference at /libraries/get-started.","sidebar":"tutorialSidebar"},"functions/callback-function":{"id":"functions/callback-function","title":"Callbacks in EasyBite","description":"Callbacks let you pass functions as parameters to other functions, enabling deferred execution, event handling, and highly flexible code structures. In this guide, we\u2019ll unpack callbacks step\u2011by\u2011step, with clear examples and detailed explanations\u2014even if you\u2019ve never worked with callbacks before!","sidebar":"tutorialSidebar"},"functions/default-arguments":{"id":"functions/default-arguments","title":"Default Arguments","description":"Default arguments (also called default parameters) let you specify a fallback value for a function\u2019s parameter when the caller doesn\u2019t provide one. This feature makes your functions more flexible, reduces repetition, and documents common use cases right in the function signature. In EasyBite, default arguments are expressed using the to keyword\u2014or, if you prefer a more explicit style, with set \u2026 to. Below, we\u2019ll dive into every detail you need to understand, step by step, with plenty of examples and explanations for absolute beginners.","sidebar":"tutorialSidebar"},"functions/function-call":{"id":"functions/function-call","title":"Calling Functions","description":"Calling a function is how you execute the block of code you defined with function \u2026 end function. In EasyBite, function calls look like small statements: you write the function\u2019s name, give it the inputs (arguments), and optionally capture its output. This guide will walk you through every detail\u2014even if you\u2019ve never called a function before.","sidebar":"tutorialSidebar"},"functions/function-concept":{"id":"functions/function-concept","title":"Functions","description":"Functions are a fundamental building block in programming, and in EasyBite, they are designed to be simple, intuitive, and perfect for beginners. They allow you to organize your code into smaller, reusable pieces that can be called and executed multiple times with different inputs. This makes your programs easier to write, read, and maintain. Whether you\'re performing a simple calculation or a more complex task, functions help you encapsulate a set of operations into a named block of code that you can use whenever you need it.","sidebar":"tutorialSidebar"},"functions/naming-convension":{"id":"functions/naming-convension","title":"Naming Convention","description":"Naming conventions are a set of rules and guidelines that define how we name elements in a programming language\u2014such as variables, functions, constants, and more. These conventions are not just about style; they help make code more readable, consistent, and understandable, especially when working in teams or writing large programs.","sidebar":"tutorialSidebar"},"functions/variable-scope":{"id":"functions/variable-scope","title":"Variable Scope","description":"Variable scope determines where a variable is accessible within your code. Understanding scope is crucial to avoid naming conflicts, unexpected behaviors, and bugs. In EasyBite, scope rules are simple and beginner\u2011friendly: variables declared at the top level are global, while variables declared inside functions are local to those functions. Blocks like loops and conditionals do not create new scopes\u2014everything inside a function shares that function\u2019s scope.","sidebar":"tutorialSidebar"},"getting-started/first-program":{"id":"getting-started/first-program","title":"First Program","description":"Welcome to EasyBite! In this guide, you will write and run your first EasyBite programs, learn how to output text with the show keyword, and insert blank lines using the showline() function. By the end, you\u2019ll understand the basics of EasyBite I/O and be ready to explore more features.","sidebar":"tutorialSidebar"},"getting-started/installation":{"id":"getting-started/installation","title":"Installation","description":"EasyBite v0.3.0+ is distributed as native binaries and installers for Windows, macOS, and Linux, with no additional runtime dependencies.","sidebar":"tutorialSidebar"},"index":{"id":"index","title":"Welcome to EasyBite","description":"EasyBite is a carefully crafted programming language designed to empower beginners, including children and novices, to confidently explore coding. With its intuitive syntax and accessible concepts, EasyBite simplifies the learning process while providing robust functionality for essential programming tasks. Ideal for educational settings and self-guided learning, it equips users with the tools to build foundational skills and create meaningful projects.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Tutorial Intro","description":"Let\'s discover Docusaurus in less than 5 minutes."},"libraries/array":{"id":"libraries/array","title":"Array Library Reference","description":"The array library provides a comprehensive suite of functions for working with arrays (lists) in EasyBite. You can call these functions directly on array values using method syntax (e.g. [1,2,3].length()) or import the array module and invoke them as array.length(arr). You may also import specific functions with from array import append, remove.","sidebar":"tutorialSidebar"},"libraries/conversion":{"id":"libraries/conversion","title":"Convert Library Reference","description":"The convert library provides functions for converting values between types and checking their types at runtime. You must import the convert module to use these functions; calling them directly on values (e.g. x.toint()) is not supported.","sidebar":"tutorialSidebar"},"libraries/datetime":{"id":"libraries/datetime","title":"DateTime Library Reference","description":"The datetime library provides functions for working with dates and times in EasyBite. All date values are represented as strings in \\"YYYY-MM-DD\\" format and time values in \\"HHSS\\" format. You can import the entire module with import datetime and call functions as datetime.today(), or import specific functions with from datetime import today, datediff, timeadd, etc.","sidebar":"tutorialSidebar"},"libraries/dictionary":{"id":"libraries/dictionary","title":"Dict Library Reference","description":"The dict library provides a full set of functions for working with key\u2013value maps in EasyBite. You can call these functions directly on dictionary values using method syntax (e.g. d.add(key, value)) or import the dict module and invoke them as dict.add(d, key, value). You may also import specific functions with from dict import add, get, copy, tojson, tofile.","sidebar":"tutorialSidebar"},"libraries/filesystem":{"id":"libraries/filesystem","title":"File System Library Reference","description":"The fs library provides functions for interacting with the file system","sidebar":"tutorialSidebar"},"libraries/gui":{"id":"libraries/gui","title":"Gui Library Reference","description":"The EasyBite GUI library empowers users to build interactive applications by providing functions to create and manage forms (windows) and various controls such as buttons, labels, textboxes, and more advanced elements like treeviews and sliders. Key benefits include:","sidebar":"tutorialSidebar"},"libraries/guiexamples":{"id":"libraries/guiexamples","title":"Gui Examples","description":"Gui Example page is a page that will contain a lots of examples of GUI created by either users or officials. Anybody can share examples here.","sidebar":"tutorialSidebar"},"libraries/introduction":{"id":"libraries/introduction","title":"Libraries in EasyBite","description":"What Are Libraries?","sidebar":"tutorialSidebar"},"libraries/listener":{"id":"libraries/listener","title":"Listener Library Reference","description":"The listener library lets you build simple TCP\u2011based servers (for HTTP, custom protocols, etc.) entirely in EasyBite. You can:","sidebar":"tutorialSidebar"},"libraries/math":{"id":"libraries/math","title":"Math Library Reference","description":"The math library provides a comprehensive set of functions for numerical computation. Below is a summary table of all available functions, followed by detailed examples and their outputs.","sidebar":"tutorialSidebar"},"libraries/mysql":{"id":"libraries/mysql","title":"MySQL Library Reference","description":"MySQL is a widely\u2011used, open\u2011source, client\u2011server relational database management system. It powers countless web applications, APIs, and data stores, offering:","sidebar":"tutorialSidebar"},"libraries/plotter":{"id":"libraries/plotter","title":"Plotter Library Reference","description":"The plotter library in EasyBite provides a stateful, high-level API for creating a wide variety of charts\u2014line plots, histograms, bar and pie charts, and more\u2014by leveraging the [Plotters] crate for rendering and minifb for on-screen display. Scripts record drawing commands against a thread-local Figure, then invoke showplot, showimage, or savefig to produce the final output. All functions return Result types, so errors (such as missing figures or mismatched array lengths) are surfaced cleanly instead of crashing the runtime.","sidebar":"tutorialSidebar"},"libraries/requester":{"id":"libraries/requester","title":"Requester Library Reference","description":"The requester library (also known as the HTTP fetcher) brings full HTTP client capabilities into EasyBite. With just a few calls you can:","sidebar":"tutorialSidebar"},"libraries/socket":{"id":"libraries/socket","title":"Socket Library Reference","description":"Socket programming is the foundation of network communication in virtually every modern application. A socket is an endpoint for sending or receiving data across a network. Under the hood, sockets abstract away the details of TCP/IP or UDP protocols so you can think in terms of \u201cconnect, send, receive, close.\u201d Common socket types:","sidebar":"tutorialSidebar"},"libraries/sqlite":{"id":"libraries/sqlite","title":"SQLite Library Reference","description":"SQLite is a self\u2011contained, high\u2011reliability, embedded, full\u2011featured, public\u2011domain SQL database engine. Unlike client\u2011server databases, SQLite runs in the same process as your application and stores the entire database as a single file on disk. Because of its small footprint (under 600\xa0KB of library code), zero\u2011configuration setup, and transactional integrity, SQLite is ideal for:","sidebar":"tutorialSidebar"},"libraries/string":{"id":"libraries/string","title":"String Library Reference","description":"The string library in EasyBite offers a rich set of functions for working with text. You can use these functions either by calling them directly on string values (e.g. \\"hello\\".count()) or by importing the string module and invoking them as string.count(\\"hello\\"), or by importing specific functions with from string import count.","sidebar":"tutorialSidebar"},"libraries/system":{"id":"libraries/system","title":"System Library Reference","description":"The system library in EasyBite offers a comprehensive suite of functions to interact with the host operating system in a safe, cross\u2011platform manner. Whereas EasyBite\u2019s core language focuses on computation and data manipulation, the system library bridges the gap between script and OS\u2014letting you inspect environment variables, manage files and directories, spawn and control processes, query network settings, and detect platform details. By encapsulating these capabilities in pure EasyBite functions, you gain the power of native system calls without abandoning the comfort and security of EasyBite\u2019s runtime.","sidebar":"tutorialSidebar"},"libraries/thread":{"id":"libraries/thread","title":"Thread Library Reference","description":"The thread library in EasyBite provides a simple, safe API for concurrent execution. While EasyBite scripts run single\u2011threaded by default to avoid race conditions, many real\u2011world tasks\u2014such as I/O\u2011bound operations, heavy computations, or background work\u2014benefit from parallelism. With thread, you can:","sidebar":"tutorialSidebar"},"oop/access-modifiers":{"id":"oop/access-modifiers","title":"Access Modifiers","description":"In Object\u2011Oriented Programming, access modifiers control which parts of a class\u2014its attributes and methods\u2014are visible outside the class and which are hidden. EasyBite provides two levels of visibility:","sidebar":"tutorialSidebar"},"oop/class-attributes":{"id":"oop/class-attributes","title":"Class Attributes","description":"In Object\u2011Oriented Programming, attributes (also called properties or fields) are the pieces of data that each object of a class holds. In EasyBite, attributes define the state of an object, and methods define its behavior. This document provides a very detailed, step\u2011by\u2011step guide to declaring, initializing, accessing, and managing class attributes in EasyBite\u2014including how to use the this keyword to refer to the current object. Every concept is explained simply, with plenty of examples and outputs, so that even complete beginners can follow along.","sidebar":"tutorialSidebar"},"oop/class-relationships":{"id":"oop/class-relationships","title":"Class Relationships","description":"Understanding Class Relationships in OOP (EasyBite)","sidebar":"tutorialSidebar"},"oop/classes-objects":{"id":"oop/classes-objects","title":"Classes and Objects","description":"Classes and objects are at the heart of Object\u2011Oriented Programming (OOP). In EasyBite, classes let you define new data types\u2014blueprints for objects\u2014while objects are instances of those blueprints, each holding its own data and behavior. This document provides a very detailed, step\u2011by\u2011step guide to defining classes, creating objects, using constructors, and working with inheritance in EasyBite. Every concept is explained in simple terms with multiple examples and outputs so that even complete beginners can follow along.","sidebar":"tutorialSidebar"},"oop/constructors":{"id":"oop/constructors","title":"Constructors","description":"In Object\u2011Oriented Programming (OOP), a constructor is a special method that runs automatically when you create a new object. It allows you to set up the object\u2019s initial state\u2014assigning values to attributes, allocating resources, or performing any startup logic. In EasyBite, constructors are defined with the init keyword and closed with end init. This document provides a very detailed, step\u2011by\u2011step guide to constructors in EasyBite, with simple explanations, numerous examples, and clear outputs so that even complete beginners can follow along.","sidebar":"tutorialSidebar"},"oop/encapsulation":{"id":"oop/encapsulation","title":"Encapsulation","description":"What is Encapsulation?","sidebar":"tutorialSidebar"},"oop/inheritance":{"id":"oop/inheritance","title":"Inheritance","description":"Inheritance is one of the most powerful and foundational concepts in object-oriented programming (OOP). It allows you to create new classes based on existing classes, making your code more organized, reusable, and maintainable. In EasyBite, inheritance is implemented in a very simple and readable way, making it especially friendly for beginners.","sidebar":"tutorialSidebar"},"oop/methods":{"id":"oop/methods","title":"Methods","description":"In EasyBite\u2019s Object\u2011Oriented world, methods are the functions that live inside classes and define the behavior of your objects. While attributes hold state, methods perform actions, manipulate that state, and return results. This guide gives you a very detailed, step\u2011by\u2011step explanation of everything you need to know about methods in EasyBite\u2014from basic syntax to advanced inheritance techniques\u2014with numerous examples and clear outputs so that complete beginners can follow along.","sidebar":"tutorialSidebar"},"oop/oop-concept":{"id":"oop/oop-concept","title":"Object\u2011Oriented Programming (OOP)","description":"Object\u2011Oriented Programming (OOP) is a paradigm that organizes code around objects\u2014self\u2011contained units that bundle data (attributes) and behavior (methods) together. Rather than thinking of a program as a sequence of instructions, you think of it as a collection of interacting objects, each responsible for its own internal state and actions. This leads to code that is:","sidebar":"tutorialSidebar"},"oop/oop-facts":{"id":"oop/oop-facts","title":"OOP Frequently Asked Questions (FAQ)","description":"What is OOP?","sidebar":"tutorialSidebar"},"oop/polymorphism":{"id":"oop/polymorphism","title":"Polymorphism","description":"What is Polymorphism?","sidebar":"tutorialSidebar"},"syntax/classes":{"id":"syntax/classes","title":"classes","description":""},"syntax/comment":{"id":"syntax/comment","title":"Comments","description":"EasyBite supports both single\u2011line and multiline comments to help you document and structure your code.","sidebar":"tutorialSidebar"},"syntax/control-structures":{"id":"syntax/control-structures","title":"Control Structures","description":"Control structures are the decision\u2011making parts of a program. They let your code ask questions, choose between different paths, and decide what to do next. Think of them like traffic signals or signposts that guide your program\u2019s flow.","sidebar":"tutorialSidebar"},"syntax/datatypes-operators":{"id":"syntax/datatypes-operators","title":"Data Types and Operators","description":"EasyBite is a dynamically typed language. You don\u2019t need to declare the type of a variable \u2014 it is inferred from the value assigned using the to keyword. The = operator is not supported.","sidebar":"tutorialSidebar"},"syntax/dictionary":{"id":"syntax/dictionary","title":"Dictionaries","description":"A dictionary in EasyBite is a collection of key-value pairs, where each key maps to a corresponding value. Dictionaries are also referred to as associative arrays or hashmaps in some other programming languages.","sidebar":"tutorialSidebar"},"syntax/error-handling":{"id":"syntax/error-handling","title":"Error Handling in EasyBite","description":"Error handling is an essential feature in EasyBite to gracefully handle unexpected situations in your programs. It ensures that errors are captured, managed, and handled appropriately, allowing the program to continue functioning without crashing.","sidebar":"tutorialSidebar"},"syntax/functions":{"id":"syntax/functions","title":"functions","description":""},"syntax/intro":{"id":"syntax/intro","title":"Introduction","description":"EasyBite is a carefully crafted programming language designed to empower beginners, including children and novices, to confidently explore coding. With its intuitive syntax and accessible concepts, EasyBite simplifies the learning process while providing robust functionality for essential programming tasks. Ideal for educational settings and self-guided learning, it equips users with the tools to build foundational skills and create meaningful projects.","sidebar":"tutorialSidebar"},"syntax/keywords":{"id":"syntax/keywords","title":"Keywords","description":"Keywords in EasyBite are reserved words that have predefined meaning and are essential to the language syntax. These cannot be used as names for variables, functions, classes, or other user-defined identifiers.","sidebar":"tutorialSidebar"},"syntax/list":{"id":"syntax/list","title":"Lists","description":"A list, also known as an array, is a collection of multiple values stored in a single variable. It is one of the most useful structures in programming, allowing you to store, access, update, and manipulate a group of data efficiently.","sidebar":"tutorialSidebar"},"syntax/loops":{"id":"syntax/loops","title":"Loops","description":"Loops are control structures that automate the repetition of code blocks. By using loops, you avoid writing the same instructions over and over, improve readability, and handle large or dynamic data sets with ease.","sidebar":"tutorialSidebar"},"syntax/modules":{"id":"syntax/modules","title":"Modules","description":"A module in EasyBite is a logical collection of code that is packaged and stored in a separate file to make it reusable, organized, and easier to maintain. These modules contain functions, variables, constants, classes, and other reusable code blocks that you can import into other programs or files. The primary purpose of modules is to promote code reusability and modularity, which helps to keep the codebase clean, manageable, and maintainable.","sidebar":"tutorialSidebar"},"syntax/variables":{"id":"syntax/variables","title":"Variables","description":"Variables in EasyBite are named containers used to store data. They can hold different data types such as strings, numbers, booleans, arrays, and more. Variables must be declared before use using the declare keyword.","sidebar":"tutorialSidebar"}}}}')}}]);