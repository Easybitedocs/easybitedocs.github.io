"use strict";(self.webpackChunkeasybitedocs=self.webpackChunkeasybitedocs||[]).push([[2923],{7997:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"libraries/thread","title":"Thread Library Reference","description":"The thread library in EasyBite provides a simple, safe API for concurrent execution. While EasyBite scripts run single\u2011threaded by default to avoid race conditions, many real\u2011world tasks\u2014such as I/O\u2011bound operations, heavy computations, or background work\u2014benefit from parallelism. With thread, you can:","source":"@site/docs/libraries/thread.md","sourceDirName":"libraries","slug":"/libraries/thread","permalink":"/libraries/thread","draft":false,"unlisted":false,"editUrl":"https://github.com/Easybitedocs/easybitedocs.github.io/tree/main/docs/libraries/thread.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"System Library Reference","permalink":"/libraries/system"},"next":{"title":"Gui Library Reference","permalink":"/libraries/gui"}}');var s=n(4848),i=n(8453);const a={},d="Thread Library Reference",o={},l=[{value:"Detailed Examples",id:"detailed-examples",level:2},{value:"1. Spawning and Joining a Thread",id:"1-spawning-and-joining-a-thread",level:3},{value:"2. Pausing Inside a Thread with <code>sleep(ms)</code>",id:"2-pausing-inside-a-thread-with-sleepms",level:3},{value:"3. Parallel Computation Example",id:"3-parallel-computation-example",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"thread-library-reference",children:"Thread Library Reference"})}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"thread"})," library in EasyBite provides a simple, safe API for concurrent execution. While EasyBite scripts run single\u2011threaded by default to avoid race conditions, many real\u2011world tasks\u2014such as I/O\u2011bound operations, heavy computations, or background work\u2014benefit from parallelism. With ",(0,s.jsx)(r.code,{children:"thread"}),", you can:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"run(funcName)"}),": Spawn a native OS thread to execute a named EasyBite function."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"join(handle)"}),": Wait for a spawned thread to finish and retrieve its return value."]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"sleep(ms)"}),": Pause the current thread for a given number of milliseconds."]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["All thread operations return EasyBite ",(0,s.jsx)(r.code,{children:"Result"})," types wrapped in ",(0,s.jsx)(r.code,{children:"Value"}),", so errors in thread creation, panics inside a thread, or double\u2011joins are captured and reported rather than crashing the interpreter. The ",(0,s.jsx)(r.code,{children:"thread"})," library hides platform differences and integrates cleanly with EasyBite\u2019s error\u2011handling model."]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Function"}),(0,s.jsx)(r.th,{children:"Parameters"}),(0,s.jsx)(r.th,{children:"Description"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"run(funcName)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"funcName"})," (Function)"]}),(0,s.jsxs)(r.td,{children:["Spawn a new thread to execute the named function. Returns a ",(0,s.jsx)(r.code,{children:"ThreadHandle"}),"."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"join(handle)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"handle"})," (ThreadHandle)"]}),(0,s.jsxs)(r.td,{children:["Block until the thread represented by ",(0,s.jsx)(r.code,{children:"handle"})," completes; returns its ",(0,s.jsx)(r.code,{children:"Value"}),"."]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"sleep(ms)"})}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.code,{children:"ms"})," (Number)"]}),(0,s.jsxs)(r.td,{children:["Pause the current thread for ",(0,s.jsx)(r.code,{children:"ms"})," milliseconds."]})]})]})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"detailed-examples",children:"Detailed Examples"}),"\n",(0,s.jsx)(r.h3,{id:"1-spawning-and-joining-a-thread",children:"1. Spawning and Joining a Thread"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:"import thread\r\n\r\nfunction computeAnswer()\r\n    return 42\r\nend function\r\n\r\nset handle to thread.run(computeAnswer)\r\n\r\n// ... main script continues here ...\r\n\r\nset result to thread.join(handle)\r\nshow(result)\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Output:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"42\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.h3,{id:"2-pausing-inside-a-thread-with-sleepms",children:["2. Pausing Inside a Thread with ",(0,s.jsx)(r.code,{children:"sleep(ms)"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:'import thread\r\n\r\nfunction sleeper()\r\n    thread.sleep(500)\r\n    return "slept 500ms"\r\nend function\r\n\r\nset handle to thread.run(sleeper)\r\nset msg to thread.join(handle)\r\nshow(msg)\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"Output:"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'"slept 500ms"\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h3,{id:"3-parallel-computation-example",children:"3. Parallel Computation Example"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-ts",children:'import thread\r\n\r\nfunction sum1to1000()\r\n    set total to 0\r\n    for i from 1 to 1000\r\n        set total to total + i\r\n    end for\r\n    return total\r\nend function\r\n\r\nfunction factorial10()\r\n    set product to 1\r\n    for i from 1 to 10\r\n        set product to product * i\r\n    end for\r\n    return product\r\nend function\r\n\r\nset h1 to thread.run(sum1to1000)\r\nset h2 to thread.run(factorial10)\r\n\r\nshow("Parallel tasks started")\r\n\r\nset r1 to thread.join(h1)\r\nset r2 to thread.join(h2)\r\n\r\nshow(r1)   // 500500\r\nshow(r2)   // 3628800\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"thread"})," library empowers EasyBite scripts to leverage multicore hardware and perform background tasks without blocking the main flow. By spawning threads with ",(0,s.jsx)(r.code,{children:"run"}),", synchronizing results with ",(0,s.jsx)(r.code,{children:"join"}),", and controlling timing with ",(0,s.jsx)(r.code,{children:"sleep"}),", you can write responsive, concurrent code while preserving EasyBite\u2019s safety and simplicity. Always join every thread you spawn to collect results and handle errors, avoiding orphaned threads and ensuring robust scripts."]})]})}function h(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>d});var t=n(6540);const s={},i=t.createContext(s);function a(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);